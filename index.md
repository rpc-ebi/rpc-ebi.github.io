---
layout: default
---

# Who are we?
  
Hey folks! 
It is a web-page of the EBI (European Bioinformatics Institute) based recreational programming club (RPC), which means that we just love problem solving, and do it for fun. However, there are some other purposes behind too: (1) we strive for perfection, so want to develop algorithmic thinking and make our future soft as efficient as possible, (2) we love our planet, so advocate for green computing.

Our club is open to anyone, but the meetings will be weekly in person on [put day later] in [room name] room at the EBI. If you are interested in joining us, but do not have access to the EBI's buildings, please email me: km858@cam.ac.uk.


# Prerequisites. 
While we do not have any prerequisites and want to make RCP an inclusive and safe place for active learning, we think that knowing basics of data structures could be beneficial. 
We would recommend a book [Grokking Algorithms: An Illustrated Guide for Programmers and Other Curious People](https://www.amazon.co.uk/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230) as a gentle into. 

# Format

A speaker picks a challenge (currently we are using [LeetCode](https://leetcode.com/) and [Rosalind](https://rosalind.info/problems/locations/)) and introduces theoretical background that could help to solve it. Then everyone implements a solution and tests it on a corresponding site. We appreciate collaborative efforts and support. After a platform assesses a solution, we discuss together how we could further improve efficiency. Then participants get a bunch of related or similar challenges for the further practice.

# Topics
As we want to make it fun and accessible for everyone, we would recommend plan the meetings according to increasing complexity of topics. However, a speaker has freedom to suggest challenges out of the initial scope. 
1. Sorting 
2. Counting Inversions
3. Linear-time selection; basic graphs, cuts, and the contraction algorithm.
4. Breadth-first and depth-first search; computing strong components
5. Dijkstra's shortest-path algorithm.
6. Heaps; balanced binary search trees.
7. Hashing; bloom filters.
8. Introduction to greedy algorithms; a scheduling application; Prim's MST algorithm.
9. Kruskal's MST algorithm and applications to clustering; advanced union-find (optional).
10. Huffman codes; introduction to dynamic programming.
11. Advanced dynamic programming: the knapsack problem, sequence alignment, and optimal binary search trees.
12. The Bellman-Ford algorithm; all-pairs shortest paths.
13. NP-complete problems and exact algorithms for them.
14. Approximation algorithms for NP-complete problems.
15. Local search algorithms for NP-complete problems; the wider world of algorithms.

# Meetings
Here we are going to save material related to each meeting. 

[Link to another page](./another-page.html).



# Contacts
If you have any question, you could contact me via [email](mailto:km858@cam.ac.uk) or on [twitter](https://twitter.com/khalimurt)

[//]: # (## Header 2)

[//]: # (> This is a blockquote following a header.)

[//]: # (>)

[//]: # (> When something is important enough, you do it even if the odds are not in your favor.)

[//]: # ()
[//]: # (### Header 3)

[//]: # ()
[//]: # (```js)

[//]: # (// Javascript code with syntax highlighting.)

[//]: # (var fun = function lang&#40;l&#41; {)

[//]: # (  dateformat.i18n = require&#40;'./lang/' + l&#41;)

[//]: # (  return true;)

[//]: # (})

[//]: # (```)

[//]: # ()
[//]: # (```ruby)

[//]: # (# Ruby code with syntax highlighting)

[//]: # (GitHubPages::Dependencies.gems.each do |gem, version|)

[//]: # (  s.add_dependency&#40;gem, "= #{version}"&#41;)

[//]: # (end)

[//]: # (```)

[//]: # ()
[//]: # (#### Header 4)

[//]: # ()
[//]: # (*   This is an unordered list following a header.)

[//]: # (*   This is an unordered list following a header.)

[//]: # (*   This is an unordered list following a header.)

[//]: # ()
[//]: # (##### Header 5)

[//]: # ()
[//]: # (1.  This is an ordered list following a header.)

[//]: # (2.  This is an ordered list following a header.)

[//]: # (3.  This is an ordered list following a header.)

[//]: # ()
[//]: # (###### Header 6)

[//]: # ()
[//]: # (| head1        | head two          | three |)

[//]: # (|:-------------|:------------------|:------|)

[//]: # (| ok           | good swedish fish | nice  |)

[//]: # (| out of stock | good and plenty   | nice  |)

[//]: # (| ok           | good `oreos`      | hmm   |)

[//]: # (| ok           | good `zoute` drop | yumm  |)

[//]: # ()
[//]: # (### There's a horizontal rule below this.)

[//]: # ()
[//]: # (* * *)

[//]: # ()
[//]: # (### Here is an unordered list:)

[//]: # ()
[//]: # (*   Item foo)

[//]: # (*   Item bar)

[//]: # (*   Item baz)

[//]: # (*   Item zip)

[//]: # ()
[//]: # (### And an ordered list:)

[//]: # ()
[//]: # (1.  Item one)

[//]: # (1.  Item two)

[//]: # (1.  Item three)

[//]: # (1.  Item four)

[//]: # ()
[//]: # (### And a nested list:)

[//]: # ()
[//]: # (- level 1 item)

[//]: # (  - level 2 item)

[//]: # (  - level 2 item)

[//]: # (    - level 3 item)

[//]: # (    - level 3 item)

[//]: # (- level 1 item)

[//]: # (  - level 2 item)

[//]: # (  - level 2 item)

[//]: # (  - level 2 item)

[//]: # (- level 1 item)

[//]: # (  - level 2 item)

[//]: # (  - level 2 item)

[//]: # (- level 1 item)

[//]: # ()
[//]: # (### Small image)

[//]: # ()
[//]: # (![Octocat]&#40;https://github.githubassets.com/images/icons/emoji/octocat.png&#41;)

[//]: # ()
[//]: # (### Large image)

[//]: # ()
[//]: # (![Branching]&#40;https://guides.github.com/activities/hello-world/branching.png&#41;)

[//]: # ()
[//]: # ()
[//]: # (### Definition lists can be used with HTML syntax.)

[//]: # ()
[//]: # (<dl>)

[//]: # (<dt>Name</dt>)

[//]: # (<dd>Godzilla</dd>)

[//]: # (<dt>Born</dt>)

[//]: # (<dd>1952</dd>)

[//]: # (<dt>Birthplace</dt>)

[//]: # (<dd>Japan</dd>)

[//]: # (<dt>Color</dt>)

[//]: # (<dd>Green</dd>)

[//]: # (</dl>)

[//]: # (```)

[//]: # (Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this.)

[//]: # (```)

[//]: # ()
[//]: # (```)

[//]: # (The final element.)

[//]: # (```)
